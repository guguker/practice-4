# 1.а. Дополните схему дерева файлов и модулей пакета calculator, указав, какие модули и функции в них содержатся.

В модуле "calculator/init.py" определяется что при импорте доступны модули "basic" и "advanced".

В модуле "calculator/basic/init.py" определяется что из модуля "addition" импортируем функцию "add", а из модуля "subtraction" импортируем функцию "subtract".

В модуле "calculator/basic/addition.py" написана функция "add".

В модуле "calculator/basic/subtraction.py" написана функция "subtract".

В модуле "calculator/advanced/init.py" определяется что из модуля "exponentiation" импортируем функцию "power", а из модуля "root" импортируем функцию "square_root".

В модуле "calculator/advanced/exponentiation.py" написана функция "power".

В модуле "calculator/advanced/root.py" написана функция "square_root".

# 1.б. Объясните, какую роль играют файлы __init__.py в каждом каталоге пакета. Почему без них пакет не будет работать правильно?

Файлы init указывают Python что данный каталог является пакетом, определяет переменные и функции внутри.

Без init "пакет" не будет пакетом, то есть Python не сможет найти и импортировать модули.

# 2.a. Обратите внимание на использование переменной __all__ в файле calculator/__init__.py. Объясните, как она влияет на импорт пакета.

Она определяет какие функции, классы и переменные будут импортироваться при использовании " from package import * ".

Другие модули все равно могут быть использованы при конкретном указании их в import

# 2.б. Удалите или закомментируйте строку __all__ = ["basic", "advanced"] в файле calculator/__init__.py. Попробуйте импортировать пакет снова. Что произошло? Объясните причину возникшей проблемы.

Тогда не получится напрямую вызывать функции, объявленные в basic, теперь для их вызова перед ними необходимо писать basic.

# 2.в. Верните строку __all__ обратно. Попробуйте выполнить команду:
from calculator import *
Какие модули будут импортированы? Как можно управлять импортируемыми модулями с помощью __all__?

Импортируются модули basic и advanced, их функции могут быть вызваны напрямую.
Модули доступные к импорту в all задаются строкой all = ["basic", "advanced"] в файле init, поэтому ими можно управлять в списке, заданной в строке, удаляя/заменяя/добавляя названия модулей в списке.

# 3.а. В файле calculator/basic/__init__.py замените относительные импорты на абсолютные:
from calculator.basic.addition import add
from calculator.basic.subtraction import subtract  
Проверьте работоспособность пакета. Объясните разницу между относительным и абсолютным импортом. Какие преимущества и недостатки каждого из них?

Абсолютный импорт использует полный путь до модуля - как плюс данного метода могу выделить то, что он ясен, но объявленный таким образом путь придется менять при изменении структуры пакета, что недостатком абсолютного импорта.
Относительный импорт импортирует модули относительно текущего положения - его плюс это по сути решение проблемы абсолютного импорта, то есть его не надо менять при реорганизации пакета, однако он используется только в пакетах.

# 3.б. Предположим, что структура пакета изменилась, и папка basic была переименована в simple. Объясните, как это повлияет на абсолютные и относительные импорты. Какой импорт легче поддерживать при реорганизации структуры пакета?

Это повлияет только на абсолютный импорт, там придётся менять уже объявленные пути к модулям, тобиш basic на simple.
Логично что в данной ситуации относительный импорт легче поддерживается.

# 5.б. Запустите файл exponentiation.py напрямую. Что произошло? Какой вывод вы получили?

Так как мы напрямую запускали файл, то из-за условия name == "main", вывело 32, потому что в добавленном коде есть print(power(2, 5)).

# 5.в. Импортируйте функцию power в main.py и запустите main.py. Выполняется ли код внутри блока if __name__ == "__main__": в файле exponentiation.py при импорте? Объясните, почему.

Код не выполнился, ведь условие сработало бы только через прямой запуск файла, а сейчас файл был запущен не напрямую, а через объявление exponentiation.py

# 6.а. Выведите переменную sys.path в main.py. Объясните, какие пути в ней содержатся и как Python использует их для поиска модулей.

В ней содержатся путь проекта, путь пакетов проекта и путь до интерпретатора Python + его зависимости.
Python использует эти пути для поиска модулей, инициализированных с помощью init.py

# 6.б. Попробуйте переместить папку calculator в другую директорию, которая не входит в sys.path. Можете ли вы теперь импортировать пакет? Что нужно сделать, чтобы Python мог найти ваш пакет?

Нет, не могу.
Чтобы смочь, надо надо изменить sys.path в коде с помощью sys.path.append и указанием путя до модуля.

# 8.б. Объясните, какой способ импорта сработал, а какой нет, и почему.

Сработал абсолютный импорт, т.к. был указан абсолютный путь до модуля.
Относительный не сработал так как, Python не смог определить модуль, из которого нужно было импортировать функцию.
